package com.td.mbna.msec.auditlogging.controller;

import com.td.mbna.msec.auditlogging.model.LoggingAuditRequest;
import com.td.mbna.msec.auditlogging.model.LoggingResponse;
import com.td.mbna.msec.auditlogging.service.AuditLoggingService;
import com.td.mbna.msec.midtier.auditlog.payload.request.CreateAuditLogRequest;
import com.td.mbna.msec.midtier.auditlog.payload.response.CreateAuditLogResponse;
import com.td.mbna.msec.common.JwtTokenHandler;
import com.td.mbna.msec.common.midtier.MidTierServiceHelper;
import com.td.mbna.msec.core.session.SessionProvider;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class AuditLoggingControllerTest {

    @InjectMocks
    private AuditLoggingController auditLoggingController;

    @Mock
    private MidTierServiceHelper midTierServiceHelper;

    @Mock
    private SessionProvider sessionProvider;

    @Mock
    private JwtTokenHandler jwtTokenHandler;

    @Mock
    private AuditLoggingService auditLoggingService;

    @Mock
    private BindingResult bindingResult;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testSetExternalAuditLog_Success() {
        CreateAuditLogRequest request = new CreateAuditLogRequest();
        String token = "validToken";
        CreateAuditLogResponse response = new CreateAuditLogResponse();

        when(jwtTokenHandler.verify(token)).thenReturn(null);  // Assuming verify doesn't return a value
        when(bindingResult.hasErrors()).thenReturn(false);
        when(midTierServiceHelper.createAuditLog(request)).thenReturn(response);

        ResponseEntity<CreateAuditLogResponse> result = auditLoggingController.setExternalAuditLog(request, bindingResult, token);

        assertEquals(HttpStatus.OK, result.getStatusCode());
        assertEquals(response, result.getBody());
    }

    @Test
    void testSetExternalAuditLog_ValidationErrors() {
        CreateAuditLogRequest request = new CreateAuditLogRequest();
        String token = "validToken";

        FieldError fieldError = new FieldError("request", "field", "error message");
        when(bindingResult.hasErrors()).thenReturn(true);
        when(bindingResult.getAllErrors()).thenReturn(Collections.singletonList(fieldError));

        ResponseEntity<CreateAuditLogResponse> result = auditLoggingController.setExternalAuditLog(request, bindingResult, token);

        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());
        assertNotNull(result.getBody());
        assertTrue(result.getBody().getErrors().contains("field error message"));
    }

    @Test
    void testSetExternalAuditLog_InvalidToken() {
        CreateAuditLogRequest request = new CreateAuditLogRequest();
        String token = "invalidToken";

        doThrow(new IllegalStateException()).when(jwtTokenHandler).verify(token);

        ResponseEntity<CreateAuditLogResponse> result = auditLoggingController.setExternalAuditLog(request, bindingResult, token);

        assertEquals(HttpStatus.UNAUTHORIZED, result.getStatusCode());
        assertNull(result.getBody());
    }

    @Test
    void testSetExternalAuditLog_InternalServerError() {
        CreateAuditLogRequest request = new CreateAuditLogRequest();
        String token = "validToken";

        when(jwtTokenHandler.verify(token)).thenReturn(null);
        when(bindingResult.hasErrors()).thenReturn(false);
        when(midTierServiceHelper.createAuditLog(request)).thenThrow(new RuntimeException("Error"));

        ResponseEntity<CreateAuditLogResponse> result = auditLoggingController.setExternalAuditLog(request, bindingResult, token);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, result.getStatusCode());
        assertNotNull(result.getBody());
        assertEquals("Error handling audit log request, contact MBNA support team", result.getBody().getErrors().get(0));
    }

    @Test
    void testSetAuditLog_Success() {
        LoggingAuditRequest request = new LoggingAuditRequest();
        HttpServletRequest httpServletRequest = mock(HttpServletRequest.class);
        LoggingResponse response = new LoggingResponse();

        when(auditLoggingService.createAuditLogs(request, httpServletRequest)).thenReturn(response);

        LoggingResponse result = auditLoggingController.setAuditLog(request, httpServletRequest);

        assertEquals(response, result);
    }

    @Test
    void testCreateBadRequestResponseFromBindResult() {
        FieldError fieldError = new FieldError("objectName", "fieldName", "Field is required");
        List<ObjectError> errors = Collections.singletonList(fieldError);
        
        ResponseEntity<CreateAuditLogResponse> response = auditLoggingController.createBadRequestResponseFromBindResult(errors);
        
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue(response.getBody().getErrors().contains("fieldName Field is required"));
    }
}
