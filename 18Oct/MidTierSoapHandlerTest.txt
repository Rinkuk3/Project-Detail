package com.td.mbna.msec.common.midtier;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import javax.xml.namespace.QName;
import javax.xml.soap.SOAPMessage;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPMessageContext;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.td.mbna.msec.midtier.util.MbnaLogger;

class MidTierSoapHandlerTest {

    private MidTierSoapHandler soapHandler;

    @Mock
    private MbnaLogger logger;

    @Mock
    private SOAPMessageContext soapMessageContext;

    @Mock
    private SOAPMessage soapMessage;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        soapHandler = new MidTierSoapHandler();
        // Using reflection to set the mocked logger
        try {
            java.lang.reflect.Field field = MidTierSoapHandler.class.getDeclaredField("logger");
            field.setAccessible(true);
            field.set(soapHandler, logger);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    void testGetHeaders() {
        // Test the getHeaders method
        Set<QName> headers = soapHandler.getHeaders();
        assertNull(headers);
    }

    @Test
    void testHandleMessageWhenDebugEnabled() throws Exception {
        // Mocking the SOAPMessageContext
        when(soapMessageContext.getMessage()).thenReturn(soapMessage);
        when(soapMessageContext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY)).thenReturn(true);
        when(logger.isDebugEnabled()).thenReturn(true);

        // Test the handleMessage method
        soapHandler.handleMessage(soapMessageContext);

        // Capture the logged message
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).debug(logCaptor.capture());
        assertTrue(logCaptor.getValue().startsWith("Out: "));
    }

    @Test
    void testHandleMessageWhenDebugNotEnabled() {
        // Mocking logger not being debug enabled
        when(logger.isDebugEnabled()).thenReturn(false);

        // Test the handleMessage method
        boolean result = soapHandler.handleMessage(soapMessageContext);

        assertTrue(result); // The method should return true
        verify(logger, never()).debug(anyString()); // No logging should occur
    }

    @Test
    void testHandleFaultWhenDebugEnabled() throws Exception {
        // Mocking the SOAPMessageContext
        when(soapMessageContext.getMessage()).thenReturn(soapMessage);
        when(soapMessageContext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY)).thenReturn(false);
        when(logger.isDebugEnabled()).thenReturn(true);

        // Test the handleFault method
        soapHandler.handleFault(soapMessageContext);

        // Capture the logged message
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).debug(logCaptor.capture());
        assertTrue(logCaptor.getValue().startsWith("In: "));
    }

    @Test
    void testHandleFaultWhenDebugNotEnabled() {
        // Mocking logger not being debug enabled
        when(logger.isDebugEnabled()).thenReturn(false);

        // Test the handleFault method
        boolean result = soapHandler.handleFault(soapMessageContext);

        assertTrue(result); // The method should return true
        verify(logger, never()).debug(anyString()); // No logging should occur
    }

    @Test
    void testClose() {
        // Test the close method, which does nothing
        soapHandler.close(mock(MessageContext.class)); // No exception should be thrown
    }

    @Test
    void testLogMessageWhenMessageStringIsNull() throws Exception {
        // Mocking the SOAPMessageContext
        when(soapMessageContext.getMessage()).thenReturn(soapMessage);
        when(soapMessageContext.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY)).thenReturn(true);
        when(logger.isDebugEnabled()).thenReturn(true);
        when(soapMessage.getSOAPPart()).thenThrow(new SOAPException("SOAPException"));

        // Test logMessage method
        soapHandler.logMessage(soapMessageContext);

        // Ensure error logging occurs
        verify(logger).error(eq("logMessage"), eq("Error occurs in logging."), any(Exception.class));
    }

    @Test
    void testWasSpecificGetMessageStringReturnsNull() {
        // Test when the accessor is null
        String result = MidTierSoapHandler.wasSpecificGetMessageString(soapMessageContext);
        assertNull(result);
    }

    @Test
    void testWasSpecificGetMessageStringReturnsEmptyString() {
        // Mocking the context to return an empty string
        when(soapMessageContext.get("jaxws.message.accessor")).thenReturn("");

        String result = MidTierSoapHandler.wasSpecificGetMessageString(soapMessageContext);
        assertNull(result);
    }

    @Test
    void testWasSpecificGetMessageStringReturnsMessage() {
        // Mocking the context to return a message
        String expectedMessage = "Test Message";
        when(soapMessageContext.get("jaxws.message.accessor")).thenReturn(expectedMessage);

        String result = MidTierSoapHandler.wasSpecificGetMessageString(soapMessageContext);
        assertEquals(expectedMessage, result);
    }
}
