package com.td.mbna.msec.core.controller;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.td.mbna.msec.account.domain.AccountDetails;
import com.td.mbna.msec.common.infrastructure.util.TextProvider;
import com.td.mbna.msec.core.session.PINSession;
import com.td.mbna.msec.core.session.SessionProvider;
import com.td.mbna.msec.midtier.util.MidTierServiceHelper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.web.servlet.ModelAndView;

import static org.junit.jupiter.api.Assertions.*;

public class PinAuthenticationControllerTest {

    @InjectMocks
    private PinAuthenticationController pinAuthenticationController;

    @Mock
    private SessionProvider sessionProvider;

    @Mock
    private TextProvider textProvider;

    @Mock
    private MidTierServiceHelper midTierServiceHelper;

    @Mock
    private HttpServletRequest request;

    @Mock
    private HttpServletResponse response;

    private AccountDetails account;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        account = new AccountDetails();
    }

    @Test
    public void testPinAuthentication_WithNullAccount_ShouldRedirectToError() {
        when(sessionProvider.getCurrentOrRequestedAccount()).thenReturn(null);
        when(sessionProvider.getCurrentAccount()).thenReturn(null);
        when(sessionProvider.getConnectId()).thenReturn("testConnectId");

        ModelAndView modelAndView = pinAuthenticationController.pinAuthentication(request, response);

        assertEquals("redirect:/error", modelAndView.getViewName());
        verify(sessionProvider).getConnectId();
        verify(sessionProvider, times(1)).getCurrentOrRequestedAccount();
        verify(sessionProvider, times(1)).getCurrentAccount();
    }

    @Test
    public void testPinAuthentication_WithValidAccountAndUapAuthFlag_ShouldRedirectToViewPin() {
        account.setAccountId("account123");
        when(sessionProvider.getCurrentOrRequestedAccount()).thenReturn(account);
        when(textProvider.getText("PIN_TIMEOUT")).thenReturn("30");
        when(sessionProvider.getSessionAttribute(any())).thenReturn(true);
        when(sessionProvider.getSessionAttribute("uappaAuthenticationFlag")).thenReturn(true);
        when(sessionProvider.getSessionAttribute("IS_CARD_ACTIVATION_FLOW")).thenReturn(false);

        ModelAndView modelAndView = pinAuthenticationController.pinAuthentication(request, response);

        verify(sessionProvider).setSessionAttribute(eq("PIN_SESSION" + "account123"), any(PINSession.class));
        assertEquals("redirect:index.html#/account/pin/view-pin", modelAndView.getViewName());
        verify(midTierServiceHelper).createAuditLog("SS1406", null, false);
    }

    @Test
    public void testPinAuthentication_WithValidAccountAndCardActivationFlow_ShouldRedirectToViewPin() {
        account.setAccountId("account123");
        when(sessionProvider.getCurrentOrRequestedAccount()).thenReturn(account);
        when(textProvider.getText("PIN_TIMEOUT")).thenReturn("30");
        when(sessionProvider.getSessionAttribute(any())).thenReturn(true);
        when(sessionProvider.getSessionAttribute("uappaAuthenticationFlag")).thenReturn(true);
        when(sessionProvider.getSessionAttribute("IS_CARD_ACTIVATION_FLOW")).thenReturn(true);

        ModelAndView modelAndView = pinAuthenticationController.pinAuthentication(request, response);

        verify(sessionProvider).setSessionAttribute(eq("PIN_SESSION" + "account123"), any(PINSession.class));
        assertEquals("redirect:index.html#/pin/view-pin", modelAndView.getViewName());
        verify(midTierServiceHelper).createAuditLog("SS0208", "");
    }

    @Test
    public void testPinAuthentication_WithInvalidUapAuthFlag_ShouldRedirectToError() {
        account.setAccountId("account123");
        when(sessionProvider.getCurrentOrRequestedAccount()).thenReturn(account);
        when(textProvider.getText("PIN_TIMEOUT")).thenReturn("30");
        when(sessionProvider.getSessionAttribute(any())).thenReturn(true);
        when(sessionProvider.getSessionAttribute("uappaAuthenticationFlag")).thenReturn(null);

        ModelAndView modelAndView = pinAuthenticationController.pinAuthentication(request, response);

        assertEquals("redirect:/error", modelAndView.getViewName());
        verify(sessionProvider).getSessionAttribute("uappaAuthenticationFlag");
    }

    @Test
    public void testClearViewPinCountFlags_WithFlagSet_ShouldResetViewPinCount() {
        when(sessionProvider.getSessionAttribute("FIRST_TIME_UAPPA_AUTHENTICATED")).thenReturn(true);
        when(sessionProvider.getSessionAttribute("VIEWPIN_TIMES")).thenReturn(3);

        // Invoke the private method using reflection
        pinAuthenticationController.clearViewPinCountFlags();

        verify(sessionProvider).setSessionAttribute("VIEWPIN_TIMES", 0);
        verify(sessionProvider).setSessionAttribute("FIRST_TIME_UAPPA_AUTHENTICATED", false);
    }

    @Test
    public void testClearViewPinCountFlags_WithFlagNotSet_ShouldNotResetViewPinCount() {
        when(sessionProvider.getSessionAttribute("FIRST_TIME_UAPPA_AUTHENTICATED")).thenReturn(false);

        // Invoke the private method using reflection
        pinAuthenticationController.clearViewPinCountFlags();

        verify(sessionProvider, never()).setSessionAttribute("VIEWPIN_TIMES", 0);
        verify(sessionProvider, never()).setSessionAttribute("FIRST_TIME_UAPPA_AUTHENTICATED", false);
    }
}
